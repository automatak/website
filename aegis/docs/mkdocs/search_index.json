{
    "docs": [
        {
            "location": "/", 
            "text": "Documentation\n\n\nWelcome to the documentation for the Aegis ICS smart fuzzing framework. Aegis currently supports the following protocols:\n\n\n\n\n\n\n\n\nProtocol\n\n\nClient\n\n\nServer\n\n\n\n\n\n\n\n\n\n\nDNP3 (IEEE 1815)\n\n\nx\n\n\nx\n\n\n\n\n\n\nModbus\n\n\nx\n\n\nx\n\n\n\n\n\n\nIEC 60870-5-104\n\n\ncoming soon\n\n\nx", 
            "title": "About"
        }, 
        {
            "location": "/#documentation", 
            "text": "Welcome to the documentation for the Aegis ICS smart fuzzing framework. Aegis currently supports the following protocols:     Protocol  Client  Server      DNP3 (IEEE 1815)  x  x    Modbus  x  x    IEC 60870-5-104  coming soon  x", 
            "title": "Documentation"
        }, 
        {
            "location": "/intro/fuzzing/", 
            "text": "What is fuzzing?\n\n\nFuzzing is an automated brute-force software testing technique that stresses target software by injecting malformed,\nunexpected, or random data. Fuzzers can test file parsers, network protocols, and any other software that processes inputs.\n\n\nThere are three common types of fuzzers:\n\n\n\n\nPure random (aka \"dumb\")\n - They don't know anything about the protocol under test.\n\n\nTemplate (aka \"mutational\")\n - These fuzzers mutate a set of valid inputs such as test files or recorded packet captures.\n\n\nGenerational (aka \"smart\")\n - These fuzzers understand the protocol under test. They produce a large number of valid and invalid inputs based on a model. Aegis is this type of fuzzer.\n\n\n\n\nTypes of bugs\n\n\nFuzzing can find a wide area of critical bugs that make software crash, e.g. but not limited to:\n\n\n\n\nmemory corruption, e.g. buffer overflows\n\n\ninteger overflows\n\n\ninfinite loops\n\n\n\n\nWith the right monitoring in place, fuzzing may also find:\n\n\n\n\nsubtle memory corruptions\n\n\nresource leaks\n\n\ninformation disclosure bugs\n\n\n\n\nLimitations of fuzzing\n\n\nFuzzing cannot prove that your software is free of all defects. Most software has a virtually infinite\nset of inputs, and fuzzing can only prove that certain defects in an infinite input space don't exist. You should\nconsider fuzzing as a single, albeit vital, tool in a more complete toolbox of software validation and testing methodologies.", 
            "title": "Fuzzing"
        }, 
        {
            "location": "/intro/fuzzing/#what-is-fuzzing", 
            "text": "Fuzzing is an automated brute-force software testing technique that stresses target software by injecting malformed,\nunexpected, or random data. Fuzzers can test file parsers, network protocols, and any other software that processes inputs.  There are three common types of fuzzers:   Pure random (aka \"dumb\")  - They don't know anything about the protocol under test.  Template (aka \"mutational\")  - These fuzzers mutate a set of valid inputs such as test files or recorded packet captures.  Generational (aka \"smart\")  - These fuzzers understand the protocol under test. They produce a large number of valid and invalid inputs based on a model. Aegis is this type of fuzzer.", 
            "title": "What is fuzzing?"
        }, 
        {
            "location": "/intro/fuzzing/#types-of-bugs", 
            "text": "Fuzzing can find a wide area of critical bugs that make software crash, e.g. but not limited to:   memory corruption, e.g. buffer overflows  integer overflows  infinite loops   With the right monitoring in place, fuzzing may also find:   subtle memory corruptions  resource leaks  information disclosure bugs", 
            "title": "Types of bugs"
        }, 
        {
            "location": "/intro/fuzzing/#limitations-of-fuzzing", 
            "text": "Fuzzing cannot prove that your software is free of all defects. Most software has a virtually infinite\nset of inputs, and fuzzing can only prove that certain defects in an infinite input space don't exist. You should\nconsider fuzzing as a single, albeit vital, tool in a more complete toolbox of software validation and testing methodologies.", 
            "title": "Limitations of fuzzing"
        }, 
        {
            "location": "/intro/tools/", 
            "text": "Complementary tools\n\n\nFuzzing should not be performed in isolation.  Access to the source code and various types of instrumentation is a defender advantage that should not be taken lightly!\nSeldom is it the case in computer security that the defender has the advantage, and this gift should be used to full effect.\n\n\n\n\nCode coverage\n\n\nCode coverage tools allow developers to measure which lines of code (and possibly branches) execute in a binary. This\ntechnique is frequently used to identify gaps in unit or functional testing coverage. It is also a very\nimportant metric for fuzzing. \n\n\nIf your fuzzer isn't running a line of code, how can it possibly find a bug on that line? Feedback using the source code\nis important and we need the help of our users and members to improve the tools. Some code coverage frameworks for popular\nlanguages are listed below.\n\n\n\n\nC/C++ - \ngcov\n\n\n.NET - \nopencover\n\n\nJava - \ncobertura\n or \nemma\n\n\n\n\nRunning code coverage tools during your fuzzing sessions can help you understand your testing gaps. This feedback can help you prioritize\nyour other types of tests to mitigate these gaps.\n\n\nAutomatak uses code coverage analysis from partner source code to improve our fuzzing tools. If you identify gaps where you'd like to see\nthe fuzzing tools provide enhanced coverage, please let us now.\n\n\nDynamic analysis\n\n\nDynamic analysis refers to analyzing the runtime properties of a piece of software using instrumentation. It is useful when combined with fuzzing to identify defects\nthat may not cause an immediate crash such as:\n\n\n\n\nMemory leaks\n\n\nMemory errors (out-of-bound read/write)\n\n\nExcessive CPU/disk usage\n\n\n\n\nThe most effective tools of this type fully virtualize your software, tracking all OS calls and memory allocations. On Linux, Valgrind is an excellent example of such a tool:\n\n\n\n\nC/C++ - \nValgrind\n\n\n\n\nThe \nmemcheck\n tool, in particular, is indispensable for detecting a wide range of memory problems.", 
            "title": "Tools"
        }, 
        {
            "location": "/intro/tools/#complementary-tools", 
            "text": "Fuzzing should not be performed in isolation.  Access to the source code and various types of instrumentation is a defender advantage that should not be taken lightly!\nSeldom is it the case in computer security that the defender has the advantage, and this gift should be used to full effect.", 
            "title": "Complementary tools"
        }, 
        {
            "location": "/intro/tools/#code-coverage", 
            "text": "Code coverage tools allow developers to measure which lines of code (and possibly branches) execute in a binary. This\ntechnique is frequently used to identify gaps in unit or functional testing coverage. It is also a very\nimportant metric for fuzzing.   If your fuzzer isn't running a line of code, how can it possibly find a bug on that line? Feedback using the source code\nis important and we need the help of our users and members to improve the tools. Some code coverage frameworks for popular\nlanguages are listed below.   C/C++ -  gcov  .NET -  opencover  Java -  cobertura  or  emma   Running code coverage tools during your fuzzing sessions can help you understand your testing gaps. This feedback can help you prioritize\nyour other types of tests to mitigate these gaps.  Automatak uses code coverage analysis from partner source code to improve our fuzzing tools. If you identify gaps where you'd like to see\nthe fuzzing tools provide enhanced coverage, please let us now.", 
            "title": "Code coverage"
        }, 
        {
            "location": "/intro/tools/#dynamic-analysis", 
            "text": "Dynamic analysis refers to analyzing the runtime properties of a piece of software using instrumentation. It is useful when combined with fuzzing to identify defects\nthat may not cause an immediate crash such as:   Memory leaks  Memory errors (out-of-bound read/write)  Excessive CPU/disk usage   The most effective tools of this type fully virtualize your software, tracking all OS calls and memory allocations. On Linux, Valgrind is an excellent example of such a tool:   C/C++ -  Valgrind   The  memcheck  tool, in particular, is indispensable for detecting a wide range of memory problems.", 
            "title": "Dynamic analysis"
        }, 
        {
            "location": "/intro/aegis/", 
            "text": "Fuzzing with Aegis\n\n\nAegis is a set of fuzzing test cases for ICS/SCADA protocols. The tests are written using several different methodologies to enhance test coverage:\n\n\n\n\nmodeling of the protocol grammars\n\n\nanalysis of the protocol specifications themselves\n\n\nbrute-force (but-repeatable) randomness within appropriate encapsulation\n\n\n\n\nIt combines aspects of generational and mutational fuzzing to provide deep coverage of the target software.\n\n\nGeneric concepts\n\n\nAegis uses a plug-in architecture internally so that protocol modules and test cases can be easily added to the platform. For the user, this means\nthat the generic concepts you learn for one module are applicable to another. These concepts are the same whether you are using the console or the studio (GUI).\n\n\n\n\n\n\nModules\n are collections of test procedures for a single protocol. They may provide client and server test procedures, or these may be broken out into separate modules. Modules are also the lowest level at which the software is licensed.\n\n\n\n\n\n\nProcedures\n are sequences of test cases that exercise a specific aspect or layer of a protocol. They range in size from a handful of frames to hundreds of thousands.\n\n\n\n\n\n\nTest cases\n are a single test frame and health check sequence tied to a numeric identifier. Test cases are described in more detail below.\n\n\n\n\n\n\nHealth checks\n are known valid messages for the protocol under test that are interleaved in the test sequence to verify that the target hasn't crashed.\n\n\n\n\n\n\nTest flow\n\n\nA single test case consists of a test message, preceded or followed by one more \nhealth checks\n.\n\n\n------\n optional health check(s)\n\n\n=======\n test message   \n\n\n------\n optional health check(s)\n\n\nThis strategy will typically help the tester identify the exact test case that caused the target to fail. Sometimes, more complex bugs that involve\nsubtle memory corruptions or non-deterministic behavior will require the use of a debugger or companion tooling as described in another section. Future versions\nof Aegis may \"close the loop\" with some of these application monitors to provide more direct feedback on fault analysis to the fuzzer.\n\n\nTest case ids\n\n\nTest cases are referred to by their incrementing \nnumeric id\n. This id starts at zero, and increments to the number of the test cases in the procedure (minus one). You can skip to a \nparticular test case at any time using the \nstart\n parameter in the studio or console. When a start value is supplied, the fuzzer spins through the seeded random number generator and\nall of the test frames quickly without transmitting them. This ensures that you get the exact same frame within the procedure as if you had run through all the preceding tests.\n\n\nOther configurable generic test options are described in the studio section of the documentation.\n\n\nCommunications\n\n\nAegis uses an abstract channel interface internally. Tests are unaware of how they are communicating with the target. You need to refer to your specific protocol\nand ensure that you have configured the communications appropriately. This release supports the following channels:\n\n\n\n\nTCP client (default)\n\n\nTCP server\n\n\nserial", 
            "title": "Fuzzing with Aegis"
        }, 
        {
            "location": "/intro/aegis/#fuzzing-with-aegis", 
            "text": "Aegis is a set of fuzzing test cases for ICS/SCADA protocols. The tests are written using several different methodologies to enhance test coverage:   modeling of the protocol grammars  analysis of the protocol specifications themselves  brute-force (but-repeatable) randomness within appropriate encapsulation   It combines aspects of generational and mutational fuzzing to provide deep coverage of the target software.", 
            "title": "Fuzzing with Aegis"
        }, 
        {
            "location": "/intro/aegis/#generic-concepts", 
            "text": "Aegis uses a plug-in architecture internally so that protocol modules and test cases can be easily added to the platform. For the user, this means\nthat the generic concepts you learn for one module are applicable to another. These concepts are the same whether you are using the console or the studio (GUI).    Modules  are collections of test procedures for a single protocol. They may provide client and server test procedures, or these may be broken out into separate modules. Modules are also the lowest level at which the software is licensed.    Procedures  are sequences of test cases that exercise a specific aspect or layer of a protocol. They range in size from a handful of frames to hundreds of thousands.    Test cases  are a single test frame and health check sequence tied to a numeric identifier. Test cases are described in more detail below.    Health checks  are known valid messages for the protocol under test that are interleaved in the test sequence to verify that the target hasn't crashed.", 
            "title": "Generic concepts"
        }, 
        {
            "location": "/intro/aegis/#test-flow", 
            "text": "A single test case consists of a test message, preceded or followed by one more  health checks .  ------  optional health check(s)  =======  test message     ------  optional health check(s)  This strategy will typically help the tester identify the exact test case that caused the target to fail. Sometimes, more complex bugs that involve\nsubtle memory corruptions or non-deterministic behavior will require the use of a debugger or companion tooling as described in another section. Future versions\nof Aegis may \"close the loop\" with some of these application monitors to provide more direct feedback on fault analysis to the fuzzer.", 
            "title": "Test flow"
        }, 
        {
            "location": "/intro/aegis/#test-case-ids", 
            "text": "Test cases are referred to by their incrementing  numeric id . This id starts at zero, and increments to the number of the test cases in the procedure (minus one). You can skip to a \nparticular test case at any time using the  start  parameter in the studio or console. When a start value is supplied, the fuzzer spins through the seeded random number generator and\nall of the test frames quickly without transmitting them. This ensures that you get the exact same frame within the procedure as if you had run through all the preceding tests.  Other configurable generic test options are described in the studio section of the documentation.", 
            "title": "Test case ids"
        }, 
        {
            "location": "/intro/aegis/#communications", 
            "text": "Aegis uses an abstract channel interface internally. Tests are unaware of how they are communicating with the target. You need to refer to your specific protocol\nand ensure that you have configured the communications appropriately. This release supports the following channels:   TCP client (default)  TCP server  serial", 
            "title": "Communications"
        }, 
        {
            "location": "/install/install/", 
            "text": "Installation\n\n\nAegis is distributed as a windows MSI installer. The requirements for installation are as follows:\n\n\n\n\nWindows Vista, 7, 8, or 10\n\n\n.NET runtime 4.5 (not installed by installer) \n\n\n512 MB RAM\n\n\nAegis will not install or run in a virtual machine without a special license file\n\n\n\n\nBy default, the installer will choose a directory like the following for the installation path.\n\n\nC:\\Program Files (x86)\\Automatak\\Aegis Fuzzer\n\n\n\n\nThe executables are installed in the \nbin\n sub-directory of this folder. After a successful installation you should be able to \nrun the AegisStudio link created in your start menu's program files \nAll Programs \n Automatak \n Aegis Fuzzer \n AegisStudio\n.\n\n\nIf you have never installed a license, or your license is no longer invalid, you should see the licensing splash screen:\n\n\n\n\nLicensing\n\n\nAegis is distributed and licensed under a subscription model. Per-seat licenses are bound to particular machines via a combination\nof hardware attributes. To license your Aegis installation, follow these steps:\n\n\n\n\nInstall Aegis and run AegisStudio\n\n\nWhen the license splash screen appears, generate a hardware ID file (hid) and save it somewhere.\n\n\nEmail the hardware ID to \nlicensing@automatak.com\n along with your customer info.\n\n\nPlace the license file in the reply in the \nbin\n sub-directory of your Aegis installation.\n\n\n\n\nYour Aegis installation will now work for the term of your subscription. You will receive a warning 2 weeks prior to the expiration\nof your subscription to get a new license file.\n\n\nNote: Both the Studio and the Console runners use the same licensing mechanism.", 
            "title": "Installation"
        }, 
        {
            "location": "/install/install/#installation", 
            "text": "Aegis is distributed as a windows MSI installer. The requirements for installation are as follows:   Windows Vista, 7, 8, or 10  .NET runtime 4.5 (not installed by installer)   512 MB RAM  Aegis will not install or run in a virtual machine without a special license file   By default, the installer will choose a directory like the following for the installation path.  C:\\Program Files (x86)\\Automatak\\Aegis Fuzzer  The executables are installed in the  bin  sub-directory of this folder. After a successful installation you should be able to \nrun the AegisStudio link created in your start menu's program files  All Programs   Automatak   Aegis Fuzzer   AegisStudio .  If you have never installed a license, or your license is no longer invalid, you should see the licensing splash screen:", 
            "title": "Installation"
        }, 
        {
            "location": "/install/install/#licensing", 
            "text": "Aegis is distributed and licensed under a subscription model. Per-seat licenses are bound to particular machines via a combination\nof hardware attributes. To license your Aegis installation, follow these steps:   Install Aegis and run AegisStudio  When the license splash screen appears, generate a hardware ID file (hid) and save it somewhere.  Email the hardware ID to  licensing@automatak.com  along with your customer info.  Place the license file in the reply in the  bin  sub-directory of your Aegis installation.   Your Aegis installation will now work for the term of your subscription. You will receive a warning 2 weeks prior to the expiration\nof your subscription to get a new license file.  Note: Both the Studio and the Console runners use the same licensing mechanism.", 
            "title": "Licensing"
        }, 
        {
            "location": "/usage/studio/", 
            "text": "The Studio\n\n\nThe main form of the studio provides the following functionality:\n\n\n\n\nLoad and save test configurations to an XML format\n\n\nCreate or edit configurations\n\n\nLaunch independent test windows\n\n\n\n\nAdding suites\n\n\nTest Suites\n are collections of test procedures. They act as folders in which you can organize your tests. Aegis comes with\nrecommended test suites for each protocol that you can find in the \ntests\n subdirectory of your install, typically:\n\n\nC:\\Program Files (x86)\\Automatak\\Aegis Fuzzer\\tests\n\n\n\n\nWhen the Studio first starts up, the tree view is empty. You can load a configuration via the \nFile\n menu or you\ncan define an initial test suite by clicking \nNew\n.\n\n\n\n\nYou are presented with a set of configuration options that are applied to every procedure within the suite. A description of each option is available in a tooltip by hovering over the option name.\n\n\nThe first grouping, \nchannel\n, allows you to configure the communication channel used for every test in the suite. You can double click on any option (marked by a gear)\nto change the value. Values that are modified from their default settings are marked in \nbold\n. You can return any setting to its default by\nright clicking and selecting \nReset to default\n.\n\n\n\n\nAdding procedures\n\n\nProcedures\n are specific sets of test cases that can be individually configured and run. They appear in the main Studio form as a two circulating arrows\nunderneath suite folder(s). You can add a procedure to a suite by right clicking on a suite node in the tree and then clicking \nAdd Procedure\n.\n\n\n\n\nYou can reorder procedures within a suite by dragging and dropping the procedure nodes onto each other.\n\n\nGeneric options\n\n\nEach test procedure has a number of generic options that can be configured in addition to any per-procedure options.\n\n\n\n\n\n\nreopen\n - Close and reopen the channel before every test. This is useful in stream-based protocols where an invalid message permanently corrupts the session.\n\n\nstart\n - Start testing a particular test case id.\n\n\ncount\n - Limit the number of test cases to the specified count.\n\n\nrepeats\n - Repeat the specified test sequence (all settings) more than once. Useful for stressing non-fatal or non-deterministic bugs.\n\n\nfill\n - Specifics the source the \"fill\" value for non-random constant data.\n\n\nconstant\n - The byte value to use for constant-fill mode.\n\n\nseed\n - The seed to use for the pseudo-random number generator.\n\n\n\n\nStart\n and \ncount\n are the most frequently adjusted parameters by the user. Most of the other values already have reasonable defaults\nin the install-included test plans.\n\n\nRunning Tests\n\n\nYou can launch a suite by right clicking on a test suite and selecting \nOpen\n.\n\n\n\n\nThis action launches an independent test window with a list box of all the tests in the suite.  By default, all procedures are\nenabled to run in sequential order. You can disable individual test procedures by right clicking and selecting \nDisable\n. Clicking\nthe \nRun\n button initiates the test sequence. You cannot adjust any parameters while the tests are running.\n\n\nLog Window\n\n\nThe top panel is a running log with a built-in protocol decoder. You can right-click the log window to see available options.\n\n\n\n\n\n\nPause - Pause the window so that contents are not overwritten. This action does not pause the test itself.\n\n\nResume - Resume logging to the window.\n\n\nClear - Clear the log window contents.\n\n\nCopy to Clipboard - Save the contents to the clipboard where they can be pasted into text files.\n\n\n\n\nDouble-clicking the log window toggles the pauses or resumes logging. A paused window displays a red border.\n\n\nProcedure Info\n\n\nAn icon is displayed in the list box for each test procedure indicating its current state.\n\n\n\n\n\n\nThe first column displays the current state of the procedure. \n{ Pending, Running, Failed, Canceled, Success }\n\n\nYou can exclude individual tests from the test sequence by right-clicking and selecting \nDisable\n.\n\n\nThe user supplied name and module-unique \nId\n field are displayed for reference.\n\n\nThe final column, \nParams\n, displays any non-default settings. This includes overridden module/channel settings.\n\n\n\n\nYou can override procedure settings for each test by right-clicking on its row and selecting \nOptions\n. \nChanging settings in the test window does\nnot modify the values in the XML configuration\n.  If you want to permanently change settings, you must do this from the main form.\n\n\nProgress Indicators\n\n\nThere are a number of indicators of progress available.  While a test is running, a progress bar is updated that displays the current test case#/total,\ncurrent tests/sec, and an estimated time to completion.", 
            "title": "Studio"
        }, 
        {
            "location": "/usage/studio/#the-studio", 
            "text": "The main form of the studio provides the following functionality:   Load and save test configurations to an XML format  Create or edit configurations  Launch independent test windows", 
            "title": "The Studio"
        }, 
        {
            "location": "/usage/studio/#adding-suites", 
            "text": "Test Suites  are collections of test procedures. They act as folders in which you can organize your tests. Aegis comes with\nrecommended test suites for each protocol that you can find in the  tests  subdirectory of your install, typically:  C:\\Program Files (x86)\\Automatak\\Aegis Fuzzer\\tests  When the Studio first starts up, the tree view is empty. You can load a configuration via the  File  menu or you\ncan define an initial test suite by clicking  New .   You are presented with a set of configuration options that are applied to every procedure within the suite. A description of each option is available in a tooltip by hovering over the option name.  The first grouping,  channel , allows you to configure the communication channel used for every test in the suite. You can double click on any option (marked by a gear)\nto change the value. Values that are modified from their default settings are marked in  bold . You can return any setting to its default by\nright clicking and selecting  Reset to default .", 
            "title": "Adding suites"
        }, 
        {
            "location": "/usage/studio/#adding-procedures", 
            "text": "Procedures  are specific sets of test cases that can be individually configured and run. They appear in the main Studio form as a two circulating arrows\nunderneath suite folder(s). You can add a procedure to a suite by right clicking on a suite node in the tree and then clicking  Add Procedure .   You can reorder procedures within a suite by dragging and dropping the procedure nodes onto each other.", 
            "title": "Adding procedures"
        }, 
        {
            "location": "/usage/studio/#generic-options", 
            "text": "Each test procedure has a number of generic options that can be configured in addition to any per-procedure options.    reopen  - Close and reopen the channel before every test. This is useful in stream-based protocols where an invalid message permanently corrupts the session.  start  - Start testing a particular test case id.  count  - Limit the number of test cases to the specified count.  repeats  - Repeat the specified test sequence (all settings) more than once. Useful for stressing non-fatal or non-deterministic bugs.  fill  - Specifics the source the \"fill\" value for non-random constant data.  constant  - The byte value to use for constant-fill mode.  seed  - The seed to use for the pseudo-random number generator.   Start  and  count  are the most frequently adjusted parameters by the user. Most of the other values already have reasonable defaults\nin the install-included test plans.", 
            "title": "Generic options"
        }, 
        {
            "location": "/usage/studio/#running-tests", 
            "text": "You can launch a suite by right clicking on a test suite and selecting  Open .   This action launches an independent test window with a list box of all the tests in the suite.  By default, all procedures are\nenabled to run in sequential order. You can disable individual test procedures by right clicking and selecting  Disable . Clicking\nthe  Run  button initiates the test sequence. You cannot adjust any parameters while the tests are running.", 
            "title": "Running Tests"
        }, 
        {
            "location": "/usage/studio/#log-window", 
            "text": "The top panel is a running log with a built-in protocol decoder. You can right-click the log window to see available options.    Pause - Pause the window so that contents are not overwritten. This action does not pause the test itself.  Resume - Resume logging to the window.  Clear - Clear the log window contents.  Copy to Clipboard - Save the contents to the clipboard where they can be pasted into text files.   Double-clicking the log window toggles the pauses or resumes logging. A paused window displays a red border.", 
            "title": "Log Window"
        }, 
        {
            "location": "/usage/studio/#procedure-info", 
            "text": "An icon is displayed in the list box for each test procedure indicating its current state.    The first column displays the current state of the procedure.  { Pending, Running, Failed, Canceled, Success }  You can exclude individual tests from the test sequence by right-clicking and selecting  Disable .  The user supplied name and module-unique  Id  field are displayed for reference.  The final column,  Params , displays any non-default settings. This includes overridden module/channel settings.   You can override procedure settings for each test by right-clicking on its row and selecting  Options .  Changing settings in the test window does\nnot modify the values in the XML configuration .  If you want to permanently change settings, you must do this from the main form.", 
            "title": "Procedure Info"
        }, 
        {
            "location": "/usage/studio/#progress-indicators", 
            "text": "There are a number of indicators of progress available.  While a test is running, a progress bar is updated that displays the current test case#/total,\ncurrent tests/sec, and an estimated time to completion.", 
            "title": "Progress Indicators"
        }, 
        {
            "location": "/usage/console/", 
            "text": "The Console\n\n\nThe console provides an alternate means of running test procedures on the shell. Test modules and procedures are invoked using the \n-mid\n (module id)\nand \n-pid\n (procedure id) flags. All options available in the Studio are available in the console via a flag with the same name.\n\n\n\n\nLicensing and the PATH\n\n\nThe console uses the same license file as the studio. Both applications look for the license file in the same\ndirectory as the executable itself. This means that you can run the application from the working directory of your choice.\n\n\nThe Windows installer automatically adds the \nbin\n sub-directory of your system's installation to the PATH environment variable. By default,\nyou can launch \nAegisConsole\n from any directory in the shell.", 
            "title": "Console"
        }, 
        {
            "location": "/usage/console/#the-console", 
            "text": "The console provides an alternate means of running test procedures on the shell. Test modules and procedures are invoked using the  -mid  (module id)\nand  -pid  (procedure id) flags. All options available in the Studio are available in the console via a flag with the same name.", 
            "title": "The Console"
        }, 
        {
            "location": "/usage/console/#licensing-and-the-path", 
            "text": "The console uses the same license file as the studio. Both applications look for the license file in the same\ndirectory as the executable itself. This means that you can run the application from the working directory of your choice.  The Windows installer automatically adds the  bin  sub-directory of your system's installation to the PATH environment variable. By default,\nyou can launch  AegisConsole  from any directory in the shell.", 
            "title": "Licensing and the PATH"
        }, 
        {
            "location": "/protocols/dnp3/", 
            "text": "About DNP3\n\n\nDNP3 is a complex SCADA protocol with 3 layers.\n\n\n\n\nlink\n\n\ntransport\n\n\napplication\n\n\n\n\nThe link and transport layers for DNP3 are identical for the client (master) and server (outstation). The same test cases\ncan be applied to both at these layers.\n\n\nThe application layer contains a myriad of object types defined by a \ngroup\n and \nvariation\n. The semantic meaning of these objects depends on\nthe \nfunction code\n (e.g. READ, WRITE, OPERATE) and the receiver (client/server).\n\n\nDNP3 has an \nunsolicited\n reporting mode whereby the outstation initiates communications. This is very useful for testing the master response parsing\nwithout having to wait for requests.\n\n\nFunctions supported\n\n\nThe DNP3 fuzzer provides good coverage of the DNP3 link, transport, and application layers. Specialized test cases are provided for each layer\nand some targeted test cases are provided for known failure points within layers such as transport reassembly buffer overflows.\n\n\nThere are some known gaps within the current version. Notably the following object groups are not explicitly modeled:\n\n\n\n\nGroup 0 - Device Attributes\n\n\nGroup 70 - File transfer / free-form qualifier 0x5B\n\n\nGroup 80 - Datasets \n\n\nGroup 120 - Secure authentication objects\n\n\n\n\nThis is not to say that Aegis cannot find bugs related to this functionality. The \napp-rand-request\n and \napp-rand-unsol\n procedures produce pseudo-random\nASDUs with many unknown function codes and qualifiers. It is just less likely that bugs in these objects will be found because they are not yet directly modeled\nin the \napp-request\n and \napp-unsol\n procedures.\n\n\nHealth checks\n\n\nDNP3 tests optionally use a feature of the link layer to identify if a target has failed. After every attack frame, the fuzzer sends a link layer request\nand expects a response.\n\n\nThe fuzzer no longer validates the response, it just expects some valid link layer frame to indicate the target is still alive. You can configure two types of health\nchecks:\n\n\n\n\nLINK_STATUS (default)\n\n\nRESET_LINK_STATES\n\n\n\n\nMost implementations will work well with the defaults. Some non-conformant implementations may require the alternative health type.\n\n\nHandshaking\n\n\nThe fuzzer can perform some automatic handshaking in response to certain messages. This keeps the target happy, particularly during the master startup sequence.\n\n\n\n\nUNCONFIRMED_USER_DATA - The fuzzer parses the application layer header and if the frame is any function code other than RESPONSE or UNSOLICITED_RESPONSE it responds with a NULL application response with the same sequence number.\n\n\nCONFIRMED_USER_DATA - The fuzzer first responses with a link layer ACK and then handles the message the same as UNCONFIRMED.\n\n\nRESET_LINK_STATES - The fuzzer responses with an ACK.\n\n\nREQUEST_LINK_STATES - The fuzzer responses with a LINK_STATUS.\n\n\n\n\nParameters\n\n\nA number of DNP3 specific parameters are available at the module level.\n\n\n\n\n\n\nsrc\n -  Source address - The link-layer source address. This is address of the fuzzer itself.\n\n\n\n\n\n\ndest\n - Destination address - The link-layer source address. This is address of the fuzzer itself, i.e. who you are pretending to be.\n\n\n\n\n\n\nmaster\n - Link-layer master bit - This setting configures the link layer 'master' bit for fuzzing masters or outstations (default). \n\n\n\n\n\n\nretries\n - Number of health-check retries - The number of attempts the fuzzer will make to query the target with a health check before deciding it has failed.\n\n\n\n\n\n\ntimeout\n - Health-check timeout - The timeout (in milliseconds) for reading a link layer frame from the target during a health-check.\n\n\n\n\n\n\nhealthType\n - Health-check type -  Enumeration [LinkStatus, ResetLink, None] that defines what kind of health check to use.\n\n\n\n\n\n\nhealthMode\n - Health-check mode - Enumeration [Before, After] that determines when the health check occurs relative to the test frame.\n\n\n\n\n\n\nProcedures\n\n\n\n\n\n\nlink\n - Link layer (outstation or master) - Fuzzes the link layer using many permutations of control octets, lengths, and special addresses.\n\n\n\n\n\n\ntransport\n - Transport layer (outstation or master) - Fuzzes the transport layer with unexpected lengths, sequence numbers, and over-sized ASDUs.\n\n\n\n\n\n\napp-request\n - Application layer requests (outstation) - Fuzzes the application layer with a large number of function codes, qualifier codes, and \nmalformed contents. Explicitly sends start/stop/count values likely to cause integer overflows.\n\n\n\n\n\n\napp-unsol\n - Application layer unsolicited (master) - Fuzzes the application layer with a large number of unsolicited responses (master)\n\n\n\n\n\n\nrand-app-request\n - Randomized application layer requests (outstation) - Fuzzes the application layer with semi-random requests. Capable of \nfinding some bugs in functions, qualifiers, and objects not explicitly modeled elsewhere.\n\n\n\n\n\n\nrand-app-unsol\n - Randomized application layer unsolicited responses (master) - Fuzzes the application layer with semi-random unsolicited\nresponses. Capable of finding some bugs in qualifiers and objects not explicitly modeled elsewhere.\n\n\n\n\n\n\napp-octet-unsol\n - Unsolicited 0-length octet strings (groups 110-113) (master) - Tests for a specific, but common, bug in the handling of \nGroup 110-113 variation 0\n\n\n\n\n\n\napp-octet-write\n - Unsolicited 0-length octet strings (groups 110-113) (outstation) - Similar to \napp-octet-unsol\n, but performs a WRITE of a \nlarge numbers of 0-length octet string headers\n\n\n\n\n\n\nTest Plans\n\n\nYour Aegis installation of contains recommended test plans for DNP3 outstations and masters.\n\n\n\n\nplans\\dnp3-master.xml\n\n\nplans\\dnp3-outstation.xml\n\n\n\n\nIn most cases, the only parameters you need to adjust will be the source and destination link layer addresses of the target, and possibly the \nhost (IP) parameter if you're testing an external target. Refer to the parameters section if you need to adjust timeouts or health checking.\n\n\nThe recommended test plan repeats some of the procedures with different fill or random seeds. It is recommended that you follow the plan for maximum efficacy, but\non slow DNP3 implementations, this could take a long time. Some DNP3 implementations can handle hundreds of test cases per second, while others only seem to handle\na couple dozen. It may be worth figuring out why the implementation is slow to respond to health checks or requests. You might consider running additional random seeds \nbesides zero if your have enough time.\n\n\nThe last test case in each plan generates random application layer data within appropriate encapsulation. It is arbitrarily set to 1,000,000\niterations. Run as many iterations as you can tolerate with the speed of your device.", 
            "title": "DNP3"
        }, 
        {
            "location": "/protocols/dnp3/#about-dnp3", 
            "text": "DNP3 is a complex SCADA protocol with 3 layers.   link  transport  application   The link and transport layers for DNP3 are identical for the client (master) and server (outstation). The same test cases\ncan be applied to both at these layers.  The application layer contains a myriad of object types defined by a  group  and  variation . The semantic meaning of these objects depends on\nthe  function code  (e.g. READ, WRITE, OPERATE) and the receiver (client/server).  DNP3 has an  unsolicited  reporting mode whereby the outstation initiates communications. This is very useful for testing the master response parsing\nwithout having to wait for requests.", 
            "title": "About DNP3"
        }, 
        {
            "location": "/protocols/dnp3/#functions-supported", 
            "text": "The DNP3 fuzzer provides good coverage of the DNP3 link, transport, and application layers. Specialized test cases are provided for each layer\nand some targeted test cases are provided for known failure points within layers such as transport reassembly buffer overflows.  There are some known gaps within the current version. Notably the following object groups are not explicitly modeled:   Group 0 - Device Attributes  Group 70 - File transfer / free-form qualifier 0x5B  Group 80 - Datasets   Group 120 - Secure authentication objects   This is not to say that Aegis cannot find bugs related to this functionality. The  app-rand-request  and  app-rand-unsol  procedures produce pseudo-random\nASDUs with many unknown function codes and qualifiers. It is just less likely that bugs in these objects will be found because they are not yet directly modeled\nin the  app-request  and  app-unsol  procedures.", 
            "title": "Functions supported"
        }, 
        {
            "location": "/protocols/dnp3/#health-checks", 
            "text": "DNP3 tests optionally use a feature of the link layer to identify if a target has failed. After every attack frame, the fuzzer sends a link layer request\nand expects a response.  The fuzzer no longer validates the response, it just expects some valid link layer frame to indicate the target is still alive. You can configure two types of health\nchecks:   LINK_STATUS (default)  RESET_LINK_STATES   Most implementations will work well with the defaults. Some non-conformant implementations may require the alternative health type.", 
            "title": "Health checks"
        }, 
        {
            "location": "/protocols/dnp3/#handshaking", 
            "text": "The fuzzer can perform some automatic handshaking in response to certain messages. This keeps the target happy, particularly during the master startup sequence.   UNCONFIRMED_USER_DATA - The fuzzer parses the application layer header and if the frame is any function code other than RESPONSE or UNSOLICITED_RESPONSE it responds with a NULL application response with the same sequence number.  CONFIRMED_USER_DATA - The fuzzer first responses with a link layer ACK and then handles the message the same as UNCONFIRMED.  RESET_LINK_STATES - The fuzzer responses with an ACK.  REQUEST_LINK_STATES - The fuzzer responses with a LINK_STATUS.", 
            "title": "Handshaking"
        }, 
        {
            "location": "/protocols/dnp3/#parameters", 
            "text": "A number of DNP3 specific parameters are available at the module level.    src  -  Source address - The link-layer source address. This is address of the fuzzer itself.    dest  - Destination address - The link-layer source address. This is address of the fuzzer itself, i.e. who you are pretending to be.    master  - Link-layer master bit - This setting configures the link layer 'master' bit for fuzzing masters or outstations (default).     retries  - Number of health-check retries - The number of attempts the fuzzer will make to query the target with a health check before deciding it has failed.    timeout  - Health-check timeout - The timeout (in milliseconds) for reading a link layer frame from the target during a health-check.    healthType  - Health-check type -  Enumeration [LinkStatus, ResetLink, None] that defines what kind of health check to use.    healthMode  - Health-check mode - Enumeration [Before, After] that determines when the health check occurs relative to the test frame.", 
            "title": "Parameters"
        }, 
        {
            "location": "/protocols/dnp3/#procedures", 
            "text": "link  - Link layer (outstation or master) - Fuzzes the link layer using many permutations of control octets, lengths, and special addresses.    transport  - Transport layer (outstation or master) - Fuzzes the transport layer with unexpected lengths, sequence numbers, and over-sized ASDUs.    app-request  - Application layer requests (outstation) - Fuzzes the application layer with a large number of function codes, qualifier codes, and \nmalformed contents. Explicitly sends start/stop/count values likely to cause integer overflows.    app-unsol  - Application layer unsolicited (master) - Fuzzes the application layer with a large number of unsolicited responses (master)    rand-app-request  - Randomized application layer requests (outstation) - Fuzzes the application layer with semi-random requests. Capable of \nfinding some bugs in functions, qualifiers, and objects not explicitly modeled elsewhere.    rand-app-unsol  - Randomized application layer unsolicited responses (master) - Fuzzes the application layer with semi-random unsolicited\nresponses. Capable of finding some bugs in qualifiers and objects not explicitly modeled elsewhere.    app-octet-unsol  - Unsolicited 0-length octet strings (groups 110-113) (master) - Tests for a specific, but common, bug in the handling of \nGroup 110-113 variation 0    app-octet-write  - Unsolicited 0-length octet strings (groups 110-113) (outstation) - Similar to  app-octet-unsol , but performs a WRITE of a \nlarge numbers of 0-length octet string headers", 
            "title": "Procedures"
        }, 
        {
            "location": "/protocols/dnp3/#test-plans", 
            "text": "Your Aegis installation of contains recommended test plans for DNP3 outstations and masters.   plans\\dnp3-master.xml  plans\\dnp3-outstation.xml   In most cases, the only parameters you need to adjust will be the source and destination link layer addresses of the target, and possibly the \nhost (IP) parameter if you're testing an external target. Refer to the parameters section if you need to adjust timeouts or health checking.  The recommended test plan repeats some of the procedures with different fill or random seeds. It is recommended that you follow the plan for maximum efficacy, but\non slow DNP3 implementations, this could take a long time. Some DNP3 implementations can handle hundreds of test cases per second, while others only seem to handle\na couple dozen. It may be worth figuring out why the implementation is slow to respond to health checks or requests. You might consider running additional random seeds \nbesides zero if your have enough time.  The last test case in each plan generates random application layer data within appropriate encapsulation. It is arbitrarily set to 1,000,000\niterations. Run as many iterations as you can tolerate with the speed of your device.", 
            "title": "Test Plans"
        }, 
        {
            "location": "/protocols/modbus/", 
            "text": "About Modbus TCP\n\n\nVanilla Modbus TCP is a simple protocol that utilizes a basic request-response design. The specification is available from \nModbus.org\n.\nat no charge.\n\n\nThe protocol transports application layer messages uses a simple envelope called the MBAP. The application layer itself supports function codes that completely\ndetermine the shape of the contents.\n\n\nModbus servers are easy to fuzz test. You can simply iterate through the various function code models. Modbus clients are more challenging, because any decent\nimplementation will only parse response data that appears to be from the request. In other words, you will usually only be testing the parser for that particular\nrequest. This is very different to a DNP3 that has function  + object semantics that allow for a nearly infinite number of permutations. To thoroughly test a Modbus\nclient, the tester must iteratively reconfigure and test every possible function code that can be sent from the master.\n\n\nFunctions supported\n\n\nThe Modbus fuzzer provides good coverage via modeling of the following commonly-used function codes:\n\n\n\n\nRead coils (0x01)\n\n\nRead discrete inputs (0x02)\n\n\nRead holding registers (0x03)\n\n\nRead input registers (0x04)\n\n\nWrite single coil (0x05)\n\n\nWrite single register (0x06)\n\n\nWrite multiple coils (0x0F)\n\n\nWrite multiple registers (0x10)\n\n\n\n\nFuture enhancements:\n\n\n\n\nAdditional function code modeling\n\n\nProcedures that inject random application layer data\n\n\n\n\nHealth checks\n\n\nThe Modbus slave tests optionally use a simple READ_COILS request as a health check. This check can be disabled.\n\n\nModbus clients do not send a health check message, as there is no request you can send to a client to stimulate a response. Instead, the fuzzer waits\nfor the next request as a health check, and then sends the next test frame with the same transaction id as the request.\n\n\nParameters\n\n\nParameters differ for the slave and master tests.\n\n\nSlave\n\n\n\n\n\n\nunitid\n -  The unit id of the modbus slave - This is the most common parameter and must be adjusted for to match the configuration of the target.\n\n\n\n\n\n\nretries\n - Health check retries -  The number of times the health check will be tried before failing the test procedure.\n\n\n\n\n\n\ntimeout\n - Read timeout (ms) - The read timeout in milliseconds for the health check\n\n\n\n\n\n\nhealthType\n - Health check type - The health check type to use [ReadCoils, None]\n\n\n\n\n\n\nhealthMode\n - Health check mode - Enumeration [Before, After] that determines when the health check occurs relative to the test frame.\n\n\n\n\n\n\nMaster\n\n\n\n\ntimeout\n - Read timeout (ms) - The read timeout in milliseconds to wait for a request before failing the test procedure.\n\n\n\n\nProcedures\n\n\n\n\n\n\npdu-request\n - Slave PDU request - Sends a large number of malformed and unexpected PDUs to a slave. Can be re-run with multiple seeds.\n\n\n\n\n\n\npdu-response\n - Master PDU response - Sends a malformed or unexpected response after each request from the master. This procedure should be run \nfor  each request type. Most Modbus masters allow polls to be configured at a arbitrarily high rate. At may not be possible to test write coil/register \nfunctionality any way other than manually without the source code.\n\n\n\n\n\n\nTest Plans\n\n\nYour Aegis installation of contains recommended test plans for Modbus slaves and masters.\n\n\n\n\nplans\\modbus-master.xml\n\n\nplans\\modbus-slave.xml\n\n\n\n\nIn most cases, the only parameters you need to adjust will be the \nunitid\n of the target when testing slaves, and possibly the \nhost (IP) parameter if you're testing an external target. Refer to the parameters section if you need to adjust timeouts or health checking.\n\n\nThe recommended test plan repeats some of the procedures with different fill or random seeds.\n\n\nYou should repeat the full master test plan with a high-frequency request for each function code that you can configure to do so. For instance, you might have\nfour master configurations that respectively scan:\n\n\n\n\nRead coils (0x01)\n\n\nRead discrete inputs (0x02)\n\n\nRead holding registers (0x03)\n\n\nRead input registers (0x04)\n\n\n\n\nIf you can configure your software to send control requests, run the suite against those function codes as well.", 
            "title": "Modbus"
        }, 
        {
            "location": "/protocols/modbus/#about-modbus-tcp", 
            "text": "Vanilla Modbus TCP is a simple protocol that utilizes a basic request-response design. The specification is available from  Modbus.org .\nat no charge.  The protocol transports application layer messages uses a simple envelope called the MBAP. The application layer itself supports function codes that completely\ndetermine the shape of the contents.  Modbus servers are easy to fuzz test. You can simply iterate through the various function code models. Modbus clients are more challenging, because any decent\nimplementation will only parse response data that appears to be from the request. In other words, you will usually only be testing the parser for that particular\nrequest. This is very different to a DNP3 that has function  + object semantics that allow for a nearly infinite number of permutations. To thoroughly test a Modbus\nclient, the tester must iteratively reconfigure and test every possible function code that can be sent from the master.", 
            "title": "About Modbus TCP"
        }, 
        {
            "location": "/protocols/modbus/#functions-supported", 
            "text": "The Modbus fuzzer provides good coverage via modeling of the following commonly-used function codes:   Read coils (0x01)  Read discrete inputs (0x02)  Read holding registers (0x03)  Read input registers (0x04)  Write single coil (0x05)  Write single register (0x06)  Write multiple coils (0x0F)  Write multiple registers (0x10)   Future enhancements:   Additional function code modeling  Procedures that inject random application layer data", 
            "title": "Functions supported"
        }, 
        {
            "location": "/protocols/modbus/#health-checks", 
            "text": "The Modbus slave tests optionally use a simple READ_COILS request as a health check. This check can be disabled.  Modbus clients do not send a health check message, as there is no request you can send to a client to stimulate a response. Instead, the fuzzer waits\nfor the next request as a health check, and then sends the next test frame with the same transaction id as the request.", 
            "title": "Health checks"
        }, 
        {
            "location": "/protocols/modbus/#parameters", 
            "text": "Parameters differ for the slave and master tests.  Slave    unitid  -  The unit id of the modbus slave - This is the most common parameter and must be adjusted for to match the configuration of the target.    retries  - Health check retries -  The number of times the health check will be tried before failing the test procedure.    timeout  - Read timeout (ms) - The read timeout in milliseconds for the health check    healthType  - Health check type - The health check type to use [ReadCoils, None]    healthMode  - Health check mode - Enumeration [Before, After] that determines when the health check occurs relative to the test frame.    Master   timeout  - Read timeout (ms) - The read timeout in milliseconds to wait for a request before failing the test procedure.", 
            "title": "Parameters"
        }, 
        {
            "location": "/protocols/modbus/#procedures", 
            "text": "pdu-request  - Slave PDU request - Sends a large number of malformed and unexpected PDUs to a slave. Can be re-run with multiple seeds.    pdu-response  - Master PDU response - Sends a malformed or unexpected response after each request from the master. This procedure should be run \nfor  each request type. Most Modbus masters allow polls to be configured at a arbitrarily high rate. At may not be possible to test write coil/register \nfunctionality any way other than manually without the source code.", 
            "title": "Procedures"
        }, 
        {
            "location": "/protocols/modbus/#test-plans", 
            "text": "Your Aegis installation of contains recommended test plans for Modbus slaves and masters.   plans\\modbus-master.xml  plans\\modbus-slave.xml   In most cases, the only parameters you need to adjust will be the  unitid  of the target when testing slaves, and possibly the \nhost (IP) parameter if you're testing an external target. Refer to the parameters section if you need to adjust timeouts or health checking.  The recommended test plan repeats some of the procedures with different fill or random seeds.  You should repeat the full master test plan with a high-frequency request for each function code that you can configure to do so. For instance, you might have\nfour master configurations that respectively scan:   Read coils (0x01)  Read discrete inputs (0x02)  Read holding registers (0x03)  Read input registers (0x04)   If you can configure your software to send control requests, run the suite against those function codes as well.", 
            "title": "Test Plans"
        }, 
        {
            "location": "/protocols/iec104/", 
            "text": "About IEC 60870-5-104\n\n\nIEC 104 is the European cousin of DNP3. It is more complex than Modbus, but a good bit simpler than DNP3. It consists\nof two layers:\n\n\n\n\nAPCI - Application Protocol Control Information used to denote frame types for 104's network mode.\n\n\nASDU - Application Service Data Unit that containings applicaiton layer frames. This is the same for 101 and 104.\n\n\n\n\nThe application layer defines a number of \nType Ids\n which can be thought of as function codes. They define the format of the data that follows. Unlike in DNP3,\n104 ASDUs can only contain one type of data.\n\n\nFunctions supported\n\n\nThe 104 fuzzer provides support for every TypeId defined in the standard. This doesn't guarantee that all possible bugs will be found, but it means there are unlikely to\nbe any significant gaps in the test coverage.\n\n\nHealth checks\n\n\nThe fuzzer tests that the device under test (DUT) is still actively communicating by sending a U-format frame with TESTFR ACT=1. It expects the remote side to answer with\nTESTFR CON=1.\n\n\nConformance and parameters\n\n\nSome parameters in IEC 104 have configurable sizes that both sides must agree upon. Aegis uses the following values:\n\n\n\n\nA two-octet Cause of Tranmission field is used where the one-byte sender address sub-field is utilized.\n\n\nA two-octet Common Address field is used.\n\n\nA three-octet Information Object Address field is used.\n\n\n\n\nThere are the defaults for many systems, and the only settings that work with Wireshark.\n\n\nHandshaking\n\n\n\n\nThe outstation fuzzer automatically advances and increments the Transmit and Receive Sequence Numbers in the APCI.\n\n\nThe outstation fuzzer will send START_DT ACT=1 and expect START_DT CON=1 before running any tests.\n\n\n\n\nParameters\n\n\n\n\n\n\nsender-addr\n - Sender (Originator) address - The address placed in all 1-octet cause of transmission sender address fields.\n\n\n\n\n\n\ncommon-addr\n - Common address (sector) - The common address, or sector, of the DUT.\n\n\n\n\n\n\nretries\n - Number of health-check retries - The number of attempts the fuzzer will make to query the target with a health check before deciding it has failed.\n\n\n\n\n\n\ntimeout\n - Health-check timeout - The timeout (in milliseconds) for reading a link layer frame from the target during a health-check.\n\n\n\n\n\n\nProcedures\n\n\n\n\napp-request\n - Application layer requests (outstation) - Fuzzes the application layer with all control direction TypeIds with mutated and invalid contents.\n\n\nrand-app-request\n - Application layer requests (outstation) - Fuzzes the application layer with random TypeIds with random contents.\n\n\n\n\nTest Plans\n\n\nYour Aegis installation of contains recommended test plans for DNP3 outstations and masters.\n\n\n\n\nplans\\iec104-outstation.xml\n\n\n\n\nIn most cases, the only parameter you need to adjust will be the common address.\n\n\nThe recommended test plan repeats some of the procedures with different fill or random seeds. It is recommended that you follow the plan for maximum efficacy, but\non slow implementations, this could take a long time. Some implementations can handle hundreds of test cases per second, while others only seem to handle\na couple dozen. It may be worth figuring out why the implementation is slow to respond to health checks or requests. You might consider running additional random seeds \nbesides zero if your have enough time.\n\n\nThe last test case in each plan generates random application layer data within appropriate encapsulation. It is arbitrarily set to 250,000 iterations. Run as many \niterations as you can tolerate with the speed of your device.", 
            "title": "IEC 60870-5-104"
        }, 
        {
            "location": "/protocols/iec104/#about-iec-60870-5-104", 
            "text": "IEC 104 is the European cousin of DNP3. It is more complex than Modbus, but a good bit simpler than DNP3. It consists\nof two layers:   APCI - Application Protocol Control Information used to denote frame types for 104's network mode.  ASDU - Application Service Data Unit that containings applicaiton layer frames. This is the same for 101 and 104.   The application layer defines a number of  Type Ids  which can be thought of as function codes. They define the format of the data that follows. Unlike in DNP3,\n104 ASDUs can only contain one type of data.", 
            "title": "About IEC 60870-5-104"
        }, 
        {
            "location": "/protocols/iec104/#functions-supported", 
            "text": "The 104 fuzzer provides support for every TypeId defined in the standard. This doesn't guarantee that all possible bugs will be found, but it means there are unlikely to\nbe any significant gaps in the test coverage.", 
            "title": "Functions supported"
        }, 
        {
            "location": "/protocols/iec104/#health-checks", 
            "text": "The fuzzer tests that the device under test (DUT) is still actively communicating by sending a U-format frame with TESTFR ACT=1. It expects the remote side to answer with\nTESTFR CON=1.", 
            "title": "Health checks"
        }, 
        {
            "location": "/protocols/iec104/#conformance-and-parameters", 
            "text": "Some parameters in IEC 104 have configurable sizes that both sides must agree upon. Aegis uses the following values:   A two-octet Cause of Tranmission field is used where the one-byte sender address sub-field is utilized.  A two-octet Common Address field is used.  A three-octet Information Object Address field is used.   There are the defaults for many systems, and the only settings that work with Wireshark.", 
            "title": "Conformance and parameters"
        }, 
        {
            "location": "/protocols/iec104/#handshaking", 
            "text": "The outstation fuzzer automatically advances and increments the Transmit and Receive Sequence Numbers in the APCI.  The outstation fuzzer will send START_DT ACT=1 and expect START_DT CON=1 before running any tests.", 
            "title": "Handshaking"
        }, 
        {
            "location": "/protocols/iec104/#parameters", 
            "text": "sender-addr  - Sender (Originator) address - The address placed in all 1-octet cause of transmission sender address fields.    common-addr  - Common address (sector) - The common address, or sector, of the DUT.    retries  - Number of health-check retries - The number of attempts the fuzzer will make to query the target with a health check before deciding it has failed.    timeout  - Health-check timeout - The timeout (in milliseconds) for reading a link layer frame from the target during a health-check.", 
            "title": "Parameters"
        }, 
        {
            "location": "/protocols/iec104/#procedures", 
            "text": "app-request  - Application layer requests (outstation) - Fuzzes the application layer with all control direction TypeIds with mutated and invalid contents.  rand-app-request  - Application layer requests (outstation) - Fuzzes the application layer with random TypeIds with random contents.", 
            "title": "Procedures"
        }, 
        {
            "location": "/protocols/iec104/#test-plans", 
            "text": "Your Aegis installation of contains recommended test plans for DNP3 outstations and masters.   plans\\iec104-outstation.xml   In most cases, the only parameter you need to adjust will be the common address.  The recommended test plan repeats some of the procedures with different fill or random seeds. It is recommended that you follow the plan for maximum efficacy, but\non slow implementations, this could take a long time. Some implementations can handle hundreds of test cases per second, while others only seem to handle\na couple dozen. It may be worth figuring out why the implementation is slow to respond to health checks or requests. You might consider running additional random seeds \nbesides zero if your have enough time.  The last test case in each plan generates random application layer data within appropriate encapsulation. It is arbitrarily set to 250,000 iterations. Run as many \niterations as you can tolerate with the speed of your device.", 
            "title": "Test Plans"
        }, 
        {
            "location": "/faq/faq/", 
            "text": "FAQ\n\n\nDuring license validation I get the message \"Value was invalid\". What gives?\n\n\nAegis requires .NET framework 4.5 or greater to be installed. Users trying to run Aegis with .NET 4.0 are likely to \nsee this message when the program attempts to load classes not found in .NET 4.0.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/faq/#faq", 
            "text": "During license validation I get the message \"Value was invalid\". What gives?  Aegis requires .NET framework 4.5 or greater to be installed. Users trying to run Aegis with .NET 4.0 are likely to \nsee this message when the program attempts to load classes not found in .NET 4.0.", 
            "title": "FAQ"
        }
    ]
}